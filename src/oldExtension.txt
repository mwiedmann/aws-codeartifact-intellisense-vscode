// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode'
import { exec } from 'child_process'
import * as path from 'path'
import { codeaArtifactQuery } from './auth'

const nth = (str: string, char: string, nth: number) => {
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === char) {
      nth--
      if (nth === 0) {
        return i
      }
    }
  }
  return -1
}

const inDep = (t: string, line: number, idxInLine: number) => {
  // We back up from the cursor to the previous {. This signals the beginning of the section.
  // From there we back up and extract the previous "XXX" and see if it includes "dependencies"
  const idx = nth(t, '\n', line) + idxInLine

  console.log(t.substring(idx - 10, idx + 10))

  const prevBrace = t.lastIndexOf('{', idx)
  const sectionNameEndQuote = t.lastIndexOf('"', prevBrace)
  const sectionNameBeginQuote = t.lastIndexOf('"', sectionNameEndQuote)
  const isDependencySection = t
    .substring(sectionNameBeginQuote, sectionNameEndQuote)
    .toLowerCase()
    .includes('dependencies')

  return isDependencySection
}

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export async function activate(context: vscode.ExtensionContext) {
  // Use the console to output diagnostic information (console.log) and errors (console.error)
  // This line of code will only be executed once when your extension is activated
  console.log('Congratulations, your extension "yarn-aws-codeartifact-helper" is now active!')
  const packageJsonSelector = { language: 'json', pattern: '**/package.json' }

  await codeaArtifactQuery('@unqork')
  // let dis1 = vscode.languages.registerCompletionItemProvider(packageJsonSelector, {
  //   provideCompletionItems(document, position, token, context) {
  //     console.log(position.character, position.line)
  //     if (inDep(document.getText(), position.line, position.character)) {
  //     }
  //     // if (inDep(document.getText(), position.character))
  //     return [(new vscode.CompletionItem('foo'), new vscode.CompletionItem('bar'))]
  //   },
  // })

  let disposable = vscode.languages.registerHoverProvider(packageJsonSelector, {
    provideHover(document, position, token) {
      return new Promise((resolve, reject) => {
        const line = document.lineAt(position)
        const match = line.text.match(/"(.+)": ".*"/)
        if (match) {
          const currentlyOpenTabfilePath = path.dirname(vscode.window.activeTextEditor?.document.uri.fsPath || '')
          const cmd = `yarn npm info ${match[1]} --json --fields name,description,dist-tags`
          console.log(cmd)
          exec(
            cmd,
            {
              cwd: currentlyOpenTabfilePath,
            },
            (err, stdout, stderr) => {
              if (err) {
                console.error('ERROR', err)
                // node couldn't execute the command
                return null
              }

              console.log('FINISHED cmd')

              try {
                const packageInfo = JSON.parse(stdout)

                console.log('JSON Parsed output', packageInfo)
                const markdown = new vscode.MarkdownString()
                markdown.appendMarkdown(
                  `<span>
                      <h4>Code Artifact</h4>
                      <h4>${packageInfo?.name}</h4>
                      <h4>${packageInfo?.description}</h4>
                      <h4>Latest Version: ${packageInfo?.['dist-tags']?.latest}</h4>
                    </span>`,
                )
                markdown.supportHtml = true
                markdown.isTrusted = true
                resolve(new vscode.Hover(markdown))
              } catch (ex) {
                console.error('Trouble parsing the yarn info output', ex)
                // We are hacking the output a bit
              }

              reject()
            },
          )
        } else {
          reject()
        }
      })
    },
  })

  context.subscriptions.push(disposable)
}

// This method is called when your extension is deactivated
export function deactivate() {}



// ***********************************************************************************************************************

// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import {
  CompletionItem,
  CompletionItemKind,
  CompletionList,
  ExtensionContext,
  Hover,
  languages,
  SnippetString,
} from 'vscode'
import { getCodeArtifactClient } from './auth'
import { getCompletionItems, getPackageInfo } from './parser'

// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
export async function activate(context: ExtensionContext) {
  // Use the console to output diagnostic information (console.log) and errors (console.error)
  // This line of code will only be executed once when your extension is activated
  console.log('Congratulations, your extension "yarn-aws-codeartifact-helper" is now active!')

  // Cache a client so it is ready
  await getCodeArtifactClient()

  const packageJsonSelector = { language: 'json', scheme: '*', pattern: '**/package.json' }

  let d1 = languages.registerCompletionItemProvider(packageJsonSelector, {
    async provideCompletionItems(document, position, token, context) {
      const results = await getCompletionItems(document, position)
      if (results) {
        if (typeof results === 'string') {
          {
            let ciList: CompletionItem[] = []
            let name = results
            let ci = new CompletionItem(name)
            ci.kind = CompletionItemKind.Property
            ci.insertText = name
            ci.documentation = 'The currently latest version of the package'
            ciList.push(ci)

            name = `^${results}`
            ci = new CompletionItem(name)
            ci.kind = CompletionItemKind.Property
            ci.insertText = name
            ci.documentation = 'Matches the most recent major version (1.x.x)'
            ciList.push(ci)

            name = `~${results}`
            ci = new CompletionItem(name)
            ci.kind = CompletionItemKind.Property
            ci.insertText = name
            ci.documentation = 'Matches the most recent minor version (1.2.x)'
            ciList.push(ci)

            return new CompletionList(ciList)
          }
        } else if ('packages' in results) {
          const ciList = results.packages
            ?.filter((p) => p.package)
            .map((p) => {
              const name = p.namespace ? `@${p.namespace}/${p.package}` : p.package || ''
              const item = new CompletionItem(name, CompletionItemKind.Property)
              item.insertText = new SnippetString().appendText(JSON.stringify(name))
              item.filterText = JSON.stringify(name)

              return item
            })
          console.log('ciList length', ciList)
          return new CompletionList(ciList)
        }
      }
    },
  })

  context.subscriptions.push(d1)

  let d2 = languages.registerHoverProvider(packageJsonSelector, {
    async provideHover(document, position, token) {
      const results = await getPackageInfo(document, position)
      if (results) {
        return new Hover(results)
      }
    },
  })

  context.subscriptions.push(d2)
}

// This method is called when your extension is deactivated
export function deactivate() {}
